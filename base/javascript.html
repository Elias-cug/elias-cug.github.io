<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EliasLee Notes</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="EliasLee 的笔记">
    
    <link rel="preload" href="/assets/css/0.styles.f47b8e7c.css" as="style"><link rel="preload" href="/assets/js/app.342839a8.js" as="script"><link rel="preload" href="/assets/js/2.2aff70d4.js" as="script"><link rel="preload" href="/assets/js/8.cb1419cb.js" as="script"><link rel="prefetch" href="/assets/js/10.fb029f4c.js"><link rel="prefetch" href="/assets/js/11.ba7b5efb.js"><link rel="prefetch" href="/assets/js/3.2af6a81f.js"><link rel="prefetch" href="/assets/js/4.83dddbe0.js"><link rel="prefetch" href="/assets/js/5.542e9b40.js"><link rel="prefetch" href="/assets/js/6.830f519f.js"><link rel="prefetch" href="/assets/js/7.edae939d.js"><link rel="prefetch" href="/assets/js/9.bd64d811.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f47b8e7c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">EliasLee Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="base" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="base" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/base/javascript.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
    javascript
  </a></li><li class="dropdown-item"><!----> <a href="/base/css.html" class="nav-link">
    css
  </a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="base" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="base" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/base/javascript.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
    javascript
  </a></li><li class="dropdown-item"><!----> <a href="/base/css.html" class="nav-link">
    css
  </a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/base/" class="sidebar-heading clickable router-link-active open"><span>基础知识</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/base/javascript.html" aria-current="page" class="active sidebar-link">javascript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/base/javascript.html#js-基础" class="sidebar-link">JS 基础</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>基础</p> <ol><li>map 和 object 区别，hello</li> <li>foreach为啥不能跳出循环</li> <li>let const var functioin</li> <li>esm 和 cmj 区别</li> <li>esnext新增加类型</li> <li>instanceof 原理</li> <li>类型判断</li> <li>介绍下 Set, Map, WeakSet, 和 WeakMap</li> <li>三种判断数组类型的方法</li> <li>全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取</li> <li>es5/es6的继承除了写法以外还有什么区别</li> <li>如何判断一个数据是 NaN</li> <li>JS 中常见的内存泄露</li> <li>怎么监听 dom 元素出现在可见区域内</li> <li>图片模糊加载</li> <li>箭头函数和普通函数的区别</li> <li>原始 ajax 怎么取消请求</li> <li>🍎 requestAnimationFrame &amp; requestIdleCallback</li> <li>[[prototype]]链</li> <li>Object.create原理</li> <li>this绑定</li> <li>解构</li> <li>严格模式</li> <li>🍎 HTML5 file API加canvas实现图片前端JS压缩</li> <li>怎么判断一个纯对象</li> <li>dynamic import</li></ol> <h2 id="js-基础"><a href="#js-基础" class="header-anchor">#</a> JS 基础</h2> <p><strong>1. map 和 object 区别</strong></p> <ol><li>键值</li> <li>可迭代</li> <li>遍历顺序</li> <li>是否会覆盖原型</li> <li>获取长度</li> <li>转JSON --》map 怎么转 json，又怎么转回来</li> <li>性能上</li> <li>怎么选择使用 map 和 object</li></ol> <p><strong>2. foreach为啥不能跳出循环</strong>
回调函数里面不return不出去，break非法。</p> <p><strong>3. let const var functioin</strong></p> <ol><li>var 声明在浏览器环境中会挂在到window上，而 let 和 const 声明变量不会提升</li> <li>var 声明存在变量提升，let 和 const 不存在变量提升</li> <li>同一作用域下 var 可以声明同名变量，let const不能</li> <li>let 和 const 声明会形成块级作用域</li> <li>const 一旦声明必须赋值，不能用 null 占位，声明后不能再修改</li> <li>函数声明，初始化都会提升</li></ol> <p><strong>4. esm 和 cmj 区别</strong></p> <ol><li>esm 引用拷贝； cmj 值拷贝</li> <li>esm 编译时输出接口；cmj 运行时加载</li></ol> <p><strong>5. esnext新增加类型</strong></p> <ol><li>Symbol</li> <li>BigInt --》Number 限制在$2^53 - 1$ --》任意大<strong>整数</strong></li></ol> <p><strong>6. instanceof 原理</strong></p> <ol><li>case.<strong>proto</strong> === Constructor.prototype</li> <li>一直向上找</li></ol> <p><strong>7. 类型判断</strong></p> <ol><li>typeof --》null 和 function</li> <li>Object.prototype.toString.call()</li> <li>instanceof</li> <li>🍎 NaN 判断</li></ol> <p><strong>8. 介绍下 Set, Map, WeakSet, 和 WeakMap</strong></p> <ol><li>set：对象允许存储任何类型的唯一值，无论时原始值或者是对象的引用。类似于数组。</li></ol> <p>new方法：可以接受数组进行初始化</p> <p>方法：add(), has(), delete(), clear(), keys(), values(), entries(), forEach()</p> <p>使用场景：存唯一值，检测链表是否有环</p> <ol start="2"><li>weakSet: 成员都是对象；成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄露。只要这些对象在外部消失，它在 WeakMap 里面的引用就会消失。</li></ol> <p>new方法：可以接受一个数组或类似数组的对象作为参数。数组成员必须是对象</p> <p>注意 🔥: 不支持遍历</p> <ol start="3"><li>Map: 区别于object只能使用字符串作为键值，Map可以使用各种类型的值作为键值。</li></ol> <p>new方法：可以接受一个数组作为参数，改数组的成员是一个个表示键值对的数组。</p> <p>方法：set(), get(), has(), size(), delete(), clear(), keys(), values(), entries(), forEach()</p> <p>注意 🔥: 只有对同一个对象的引用， Map结构才将其视为同一个键。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">555</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><ol start="4"><li>WeakMap</li></ol> <p>类似于Map</p> <p>注意: 只接受对象作为键名（null 除外）；WeakMap 的键名所指向的对象不计入垃圾回收机制。</p> <p>场景：WeakMap 的设计目的在于，有时我们想在某个对象上面存一些数据，但这会形成对这个对象的引用。注册监听事件的listener对象很适合 WeakMap 来实现。另一个用处是部署私有属性。</p> <p>方法：get(), set(), has(), delete()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> e1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> e2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>e1<span class="token punctuation">,</span> <span class="token string">'foo 元素'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>e2<span class="token punctuation">,</span> <span class="token string">'bar 元素'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p><strong>9. 三种判断数组类型的方法</strong></p> <ol><li><p>Object.prototype.toString.call()
每一个继承 Object 的对象都有 toString 方法，如果 toString 发放没有重写的话，会返回[Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。该方法对于所有基本的类型数据都能进行判断，即使 null 和 undefined。</p></li> <li><p>instanceof
instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prorotype 。使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回true，否则返回 false。所有对象 instanceof 只能判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true</p></li> <li><p>Array.isArray()
当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 可以检测出 iframes.</p></li></ol> <p><strong>10. 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取</strong>
在 es5 中，顶层对象的属性和全局变量是等价的， var 和 function 命令声明的全局变量，自然是顶层对象</p> <p>但 es6 规定，var 命令和 function 命令声明的全局变量，依然是顶层对象的属性，但 let 和 const 命令声明的变量，不属于顶层对象的属性。</p> <p><strong>11. es5/es6的继承除了写法以外还有什么区别</strong></p> <ol><li><p>es5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上</p></li> <li><p>es6 的机制机制完全不同，实质上是先创建父类的实例对象 this （所以必须先调用父类的super方法）然后再用子类的构造函数修改 this</p></li> <li><p>es5 的继承通过原型或构造函数机制来实现</p></li> <li><p>es6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承</p></li> <li><p>子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</p></li> <li><p>注意 super 关键字指代父类的实例，即父类的 this 对象，在子类构造器中，调用 super 后，才可使用 this 关键字，否则会报错</p></li></ol> <p><strong>12. 如何判断一个数据是 NaN</strong>
NaN定义：非数字 <code>typeof NaN === 'number'</code></p> <ol><li>利用定义</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>利用NaN是唯一一个不等于任何自身的特点</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>a <span class="token operator">!==</span> a
</code></pre></div><p><strong>13. JS 中常见的内存泄露</strong></p> <ol><li>意外的全局变量</li> <li>被遗忘的计时器或回调函数</li> <li>脱离的 DOM 引用</li> <li>闭包</li></ol> <p><strong>14. 怎么监听 dom 元素出现在可见区域内</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1. getBoundingClientRect() + scroll事件 </span>
<span class="token keyword">const</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> rectObj <span class="token operator">=</span> ele<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
rectObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">right</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">bottom</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span>


<span class="token comment">// 2. IntersectionObserver()</span>
<span class="token comment">// callback 为可见性变化时的回调函数，option是配置对象</span>
<span class="token comment">// callback 可见时调用一次，不可见时调用一次</span>
<span class="token keyword">const</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entries</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> option<span class="token punctuation">)</span>
<span class="token keyword">const</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token comment">// 开始观察</span>
io<span class="token punctuation">.</span><span class="token function">observer</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>
<span class="token comment">// 停止观察</span>
io<span class="token punctuation">.</span><span class="token function">unobserver</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>
<span class="token comment">// 关闭观察器</span>
io<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>15. 图片模糊加载</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//1. 加载缩略图 2. new Image().src下载大图 3. 下载完成后将显示图片的地址更换</span>
</code></pre></div><p><strong>16. 箭头函数和普通函数的区别</strong></p> <ol><li>函数体内的 this 对象，就是定义时所在的对象，而不是适用时所在的对象</li> <li>不可以适用 arguments 对象，该对象在函数体内不存在，如果要用可以用 rest 参数代替</li> <li>不可以适用 yield 命令，因此箭头函数不能做 Generator 函数</li> <li>不可以使用 new 命令，没有子集的this，无法调用 call apply。没有 prototype 属性</li></ol> <p><strong>17. 原始 ajax 怎么取消请求</strong></p> <ol><li>abort方法</li></ol> <p><strong>18. requestAnimationFrame &amp; requestIdleCallback</strong></p> <ol><li>requestAnimationFrame 每一帧必定会执行不同，requestIdleCallback 是捡浏览器空闲来执行任务。</li> <li>假如浏览器一直处于非常忙碌的状态，requestIdleCallback 注册的任务有可能永远不会执行。此时可通过设置 timeout （见下面 API 介绍）来保证执行。</li> <li>一些低优先级的任务可使用 requestIdleCallback 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）。因为它发生在一帧的最后，此时页面布局已经完成，所以不建议在 requestIdleCallback 里再操作 DOM，这样会导致页面再次重绘。DOM 操作建议在 rAF 中进行。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 requestIdleCallback 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</li></ol> <p><strong>19. [[prototype]]链</strong></p> <ol><li><p>链的尽头指向内置的 Object.prototype</p></li> <li><p><code>myObject.foo = &quot;bar&quot;</code> 时的三种情况《你不知道的js》（145）
a) 非只读； b) 只读； c) 是一个setter；</p></li> <li><p>类函数</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>类函数会将实例foo内部的[[prototype]]链接到Foo.prototype，会形成如下等式：</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getProrotypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype

<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Foo

foo<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Foo
</code></pre></div><p><strong>20. Object.create原理</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>

<span class="token comment">// 上面等价于ES6 语法</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototype</span><span class="token punctuation">(</span><span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><p><strong>21. this绑定</strong></p> <ol><li><p>默认绑定
区分严格模式和非严格模式</p></li> <li><p>隐式绑定
回调函数丢失 this 是非常常见的</p></li> <li><p>显示绑定
call apply bind</p></li> <li><p>new 绑定
使用 new 来调用函数
a) 创建或者构造一个全新的对象
b) 这个新对象会被执行[[prototype]]连接
c) 这个新对象会绑定到函数调用的 this
d) 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</p></li> <li><p>优先级顺序
new --&gt; 显示绑定 --&gt; 隐式绑定 --&gt; 默认绑定</p></li> <li><p>箭头函数
this指向当前函数所在作用域</p></li></ol> <p><strong>22. 解构</strong></p> <ol><li>= 表示赋值默认 <code>const {a=a1} = {a: 1}</code></li> <li>: 表示起别名 <code>const {a: a1} = {a: 1}</code></li></ol> <p><strong>23. 严格模式</strong></p> <ol><li>不允许使用未声明的变量</li> <li>不允许变量重名</li> <li>不允许删除变量或对象</li> <li>不允许给只读属性赋值</li> <li>with，eval的一些限制</li> <li>禁止 this 关键字指向全局对象</li></ol> <p><strong>24. HTML5 file API加canvas实现图片前端JS压缩</strong></p> <p><strong>25. 怎么判断一个纯对象</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>

  <span class="token keyword">let</span> proto <span class="token operator">=</span> obj
  <span class="token keyword">while</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> proto
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getObjectClassLabel</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getObjectClassLabel</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'[object Object]'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token keyword">return</span> prototype <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> prototype <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype
<span class="token punctuation">}</span>
</code></pre></div><p><strong>26. dynamic import</strong></p> <ol><li>静态代码会显著减慢代码的加载速度，而且导入的代码可能用不上，或者是在导入之后其他的行为中用到。</li> <li>静态代码会增加程序内存使用</li> <li>导入的代码可能加载的时候用不上</li> <li>When the import specifier string needs to be constructed dynamically. (Static import only supports static specifiers.)</li> <li>当导入的模块有副作用时，除非某些条件为真，否则您不希望出现这些副作用。 （建议不要在模块中产生任何副作用，但有时您无法在模块依赖项中控制它。）</li></ol> <blockquote><p>仅在必要时使用动态导入。 静态形式更适合加载初始依赖项，并且可以更容易地从静态分析工具和tree-shaking中受益。</p></blockquote> <ol start="6"><li>语法
To dynamically import a module, the import keyword may be called as a function. When used this way, it returns a promise.</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'/modules/my-module.js'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Do something with the module.</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 也可以用 await 语法</span>
<span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'/modules/my-module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.342839a8.js" defer></script><script src="/assets/js/2.2aff70d4.js" defer></script><script src="/assets/js/8.cb1419cb.js" defer></script>
  </body>
</html>
